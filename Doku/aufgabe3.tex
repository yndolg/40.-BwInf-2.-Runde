\documentclass[a4paper,10pt,ngerman]{scrartcl}

\input{preamble.tex}

\begin{document}

\maketitle
\tableofcontents

\section{Lösungsidee}
\subsection{Modellierung}
Gegeben ist ein Wort $w$ aus $x_1, x_2, ..., x_n$ Zeichen, die jeweils eine Stelle der Hexadezimalzal beschreiben, und eine Maximalzahl an Umlegungen $m$. Jedes Zeichen ist ein 7-Tupel, welches für jede Position im Zeichen angibt, ob sie aktiviert oder deaktiviert ist. 

Gesucht ist nun das größte solche Wort, was sich mit maximal $m$ Umlegungen aus $w$ legen lässt.

\subsection{Lösung}

Das Problem kann mittels dynmischer Programmierung und einem anschließenden Greedy-Verfahren gelöst werden. 
Sei
\begin{align}
    f(p, e)
\end{align}
die Anzahl der Umlegungen, die mindestens benötigt werden, um insgesamt $e$ zusätliche Positionen im Teilwort $w_p, ..., w_n$ zu besetzten und eine valide Zahl zu erhalten. Die zusätzlich gesetzten Positionen zählen dabei nicht als Umlegung. Die Zahl $e$ kann auch negativ sein, was bedeutet, dass $e$ Positionen entfernt werden sollen.

Ist $f(p, e)$ für alle $p$ und $e$ bekannt, kann das maximale Wort über ein Greedy-Verfahren rekonstruiert werden. 
$f(p, e)$ kann über dynamische Programmierung berechnet werden. 

Sei dazu $d(x,y)$ die Anzahl der Stäbe, die innerhalb des Zeichens umgelegt werden müssen, um das $x$ in $y$ umzuwandeln. $d(2, 3)$ wäre beispielsweise 1 und $d(8,9) = 0$, da kein Stab umgelegt werden muss, sondern nur ein Stab entfernt wird.   
$n(x, y)$ ist analog dazu die Anzahl der Stäbchen, die entfernt bzw. hinzugefügt werden müssen, um $x$ in $y$ umzuwandeln.  $n(2, 3)$ ist beispielsweise 0 und $n(8,9)$ ist -1.
Nun gilt
\begin{align}
    f(p, e) = \min_{x\in [0, 15]} f(p + 1, e + n(w_p, x)) + d(w_p, x) + \max(n(w_p, x), 0). \label{eq:rek}
\end{align}
Die aktuelle Stelle $p$ kann zu den Zahlen 0–F umgewandelt werden. Dabei werden $n(w_p, x)$ Stäbchen frei, die im Rest des Wortes integriert werden müssen. Zu den dafür notwendigen Umlegungen werden die Umlegungen addiert, die im Zeichen $w_p$ gebracht werden ($d(w_p, x)$). 
Auch die Stäbchen, die aus dem Zeichen entfernt bzw. hinzugefügt wurden sind Umlegungen. Um diese jedoch nicht doppelt zu zählen, werden nur positive Zahlen gezählt. 
Das sorgt dafür, dass solche Umlegungen zwischen Zeichn immer in dem Zeichen gezählt werden, aus dem die Stäbchen kommen. Das Einfügen zählt dann nicht mehr als Umlegung. 
Schließlich wird das Minimum über alle möglichen Zeichen an der Position $p$ verwendet. 
 
Mit der Rekurrenz \ref{eq:rek} kann $f(p, e)$ für alle möglichen Werte bottom-up vorberechnet werden, wie in Algorithmus \ref{alg:precalc} dargestellt.
\begin{algorithm}
\caption{Berechnung von $f$}
\label{alg:precalc}
\begin{algorithmic}[1]
    \Procedure{Vorberechnen}{$w, m$}
    \State sei $dp[1, ..., n+1][-m, ..., m]$ ein neues Array
    \State $dp[n+1][-m, ..., m] \gets \begin{cases}
        0 & \text{, falls } m = 0\\
        \infty &\text{, falls } m \neq 0
    \end{cases}$ \Comment{Initialisen der Basisfälle, das leere Wort}
    \For {$p \gets n, ..., 1$}
        \For {$e \gets -m, ..., m$}
            \State{$dp[p][e] \gets \min_{x\in [0, 15]} f(p + 1, e + n(w_p, x)) + d(w_p, x) + \max(n(w_p, x), 0)$}
        \EndFor 
    \EndFor
    \State \textbf{return} $dp$
\EndProcedure
\end{algorithmic}
\end{algorithm} 

Ist $f(p, e)$ bekannt, kann die größte Zahl greedy rekonstruiert werden. Dazu wird an jeder Stelle, von links nach rechts, die größte Zahl verwendet, bei der die dann benötigten Umlegungen im Rest des Wortes nicht mehr als erlaubt sind. 
\begin{algorithm}
    \caption{Rekonstruktion der maximalen Zahl}
    \label[]{alg:reconstruct}
    \begin{algorithmic}[1]
        \Procedure{Rekonstruktion}{$w, f$}
            \State $e \gets 0$ \Comment{Aktuell überschüssige Stäbe}
            \State $z \gets m$ \Comment{Noch übrige Umlegungen}
            \State $s \gets \epsilon$  \Comment{Das rekonstruierte Wort}
        \For{$p \gets 1,...,n$}
            \For{$x \gets F,...,0$}
                \If{$f(p + 1, e + n(w_p, x)) + d(w_p) + \max(n(w_p, x), 0) \leq z$}
                    \State $e \gets e + n(w_p, x)$
                    \State $s \gets s + x$
                    \State $z \gets z - d(w_p) - \max(n(w_p, x), 0)$
                    \State \textbf{break}
                \EndIf
            \EndFor
        \EndFor
        \State \textbf{return} $s$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
Nun ist die Größte Zahl gefunden. In der Aufgabenstellung ist weiterhin gefordert, die Zwischenstände nach jeder Umlegung auszugeben. Dafür muss also eine Folge an Umlegungen gefunden werden, um vom Eingabewort zum Ergebnis zu gelangen. Weiterhin ist gefordert, dass während der Umlegungen ein Zeichen niemals vollständig geleert werden darf. 
Die Grundidee dafür ist es, alle Positionen zu finden, in denen ein Stäbchen benötigt/überflüssig ist. Daraufhin muss immer ein Stäbchen von einer bisher belegten zu einer unbelegten Stelle bewegt werden. Da es genau so viele Stellen gibt, in denen ein Stäbchen benötigt wird, wie in denen ein Stäbchen überflüssig ist es ersteinmal egal, welches Stäbchen wohin und in welcher Reihenfolge bewegt wird. Es muss jedoch darauf geachtet werden, dass keine Stelle zu einem Zeitpunkt vollständig gelehrt ist. 
\begin{algorithm}
    \caption{Finden der Umlegungen}
    \label[]{alg:moves}
    \begin{algorithmic}[1]
        \Procedure{Umlegen}{$w_1, w_2$}
            \State $e \gets []$ \Comment{Positionen mit überschüssigem Stäbchen}
            \State $n \gets []$ \Comment{Positionen, die ein Stäbchen benötigen}
        \For{$z \gets 1,..,n$} \Comment{über alle Zeichen iterieren}
            \For{$i \gets 0,...,6 $} \Comment{über die sieben Segmente iterieren}
                \If{Segment $i$ von Zeichen $z$ muss gesestzt werden}
                    \State $n$.push($(z, i)$)
                \EndIf
                \If{Segment $i$ von Zeichen $z$ muss entfernt werden}
                    \State $e$.push($(z, i)$)
                \EndIf
            \EndFor
            \While{$e.\text{size()} > 0$ und $n.\text{size()} > 0$}
                \State $a \gets e$.pop()
                \State $b \gets n$.pop()
                \State bewege Stäbchen von $a$ nach $b$
            \EndWhile
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
Das Funktionsprinzip des Algorithmus ist es, Segmente zu finden, die aktiviert bzw. deaktiviert werden müssen und diese in Listen zu vermerken. Nach jedem Zeichen wird jeweils ein zu aktivierendes und ein zu deaktivierendes Segment aus den Listen entfernt und das Stäbchen bewegt. Der Beweis, warum dadurch ein Zeichen niemals vollständig geleert werden kann, folgt unter \ref{sec:prove}.
\subsection{Analyse der Laufzeit}
Zunächst wird die Laufzeit von Algorithmus \ref{alg:precalc} analysiert.
Die Initialisierung des Arrays in Zeile 2 benötigt $T(n, m) = \Theta(n \cdot 2 m) = \Theta(n \cdot m)$ Laufzeit.
Zeile 5 benötigt eine Laufzeit von $\Theta(1)$, da der Ausdruck 15 Mal ausgewertet wird, unabhängig von $n$ und $m$.
Diese Zeile wird durch die beiden for-Schleifen $n \cdot 2m$-Mal ausgeführt. 
So ergibt sich eine Gesamtlaufzeit von 
\begin{align*}
    T(n, m) &= \Theta(n \cdot m) + \Theta(n \cdot 2m)\\
    T(n, m) &= \Theta(nm)
\end{align*}

Nun wird die Laufzeit von Algorithmus \ref{alg:reconstruct} analysiert.
Die Zeilen 2–5 benötigen insgesamt $T(n) = \Theta(1)$ Laufzeit. 
Die while-Schleife in Zeile 6 wird $n$-Mal ausgeführt, da in jedem Durchlauf $p$ um mindestens 1 erhöht wird und die Schleife terminert, wenn $p >= n$ gilt. 
Die for-Schleife in Ziele 7 wird maximal 15-Mal ausgeführt und die Zeilen 8-14 benötigen insgesamt $T(n,m) = \Theta(1)$ Laufzeit. 
So ergibt sich für die Laufzeit von Algorithmus \ref{alg:reconstruct}
\begin{align*}
    T(n,m) &= n \cdot 15 \cdot \Theta(1)\\
    T(n, m) &= \Theta(n) \cdot \Theta(1)\\
    T(n, m) &= \Theta(n)
\end{align*}

Algorithmus \ref{alg:moves} hat eine Laufzeit von $T(n) = \Theta(n)$. Die Zeilen 2 und 3 benötigen $\Theta(1)$ Zeit und werden nur einmal ausgeführt. 
Die for-Schleife aus Zeile vier wird $n$-Mal ausgeführt. 
Die Zeilen 5-12 benötigen pro Ausführung $\Theta(1)$ Laufzeit, da die for-Schleife in Zeile 5 immer konstant oft ausgeführt wird und jeweils eine konstante Laufzeit pro Iteration hat. 

Die while-Schleife in Zeile 13 wird während des gesamten Durchlauf des Algorithmus nicht öfter als $7n$-Mal aufgerufen, da jedes Segment nur einmal in die Listen eingefügt wurde. Die Zeilen 13-17 benötigen also insgesamt $O(n)$ Laufzeit.
Die Gesamtlaufzeit von Algorithmus \ref{alg:moves} ist also 
\begin{align*}
    T(n) &= n \cdot \Theta(1) + O(n)\\
    T(n) &= \Theta(n).
\end{align*}
Die drei Algorithmen haben zusammen eine Laufzeit von 
\begin{align*}
    T(n, m) &= \Theta(n) + \Theta(nm) + \Theta(n)\\
    T(n, m) &= \Theta(nm)
\end{align*}
\subsection{Analyse des Speicherbedarfs}
Das $dp$-Array von Algorithmus \ref{alg:precalc}benötigt insgesamt $n \cdot (2m + 1) = \Theta(nm)$ Speicher. Zusammen mit den Variablen $p, e$ und $x$ ergibt sich ein Speicherbedarf von $\Theta(nm) + \Theta(1) = \Theta(nm)$.

Die Rekonstruktion verwendet lediglich die Ganzzahlen $e, p, z$ und $x$, die einen Speicherbedarf von $\Theta(1)$ haben. Der String $w$ wird genau so lang wie das Eingabewort und benötigt $\Theta(n)$ Speichereinheiten. 
Insgesamt hat Algorithmus \ref{alg:reconstruct} also einen Speicherbedarf von $\Theta(1) + \Theta(n) = \Theta(n)$.

Algorithmus \ref{alg:moves} verwendet zwei Listen. Da jedes Segment nur einemal in eine der Listen eingefügt wird, können diese Zusammen niemals mehr als $7n = O(n)$ Speicher benötigen. 
Die drei Algorithmen haben zusammen einen Speicherbedarf von $\Theta(n) + \Theta(nm) + O(n)= \Theta(nm)$.
\subsection{Beweis der Richtigkeit}
Zunächst wird die Richtigkeit von Algorithmus \ref*{alg:precalc} per Induktion bewiesen.
Zur Erinnerung: $dp[p_0][e]$ soll die minimale Anzahl an Umlegungen sein, die benötigt werden, um aus dem Teilwort $w_{p_0}, ..., w_n$ und $e$ zusätzlichen Stäbchen eine valide Zahl zu erhalten.  
In Zeile 3 werden die Werte für $n+1$, also das leere Wort gesetzt. Soll kein weiteres Stäbchen verwendet werden, so ist das leere Wort eine valide Zahl und es werden keine weiteren Umlegungen verwendet. 
Sollen jedoch weitere Stäbchen verwendet werden, ist es nicht möglich, eine Valide Zahl zu bilden, da es laut Aufgabenstellung nicht erlaubt ist, weitere Stellen zu verwenden. Daher werden $\infty$ Umlegungen benötigt. 

Für den Induktionsschritt wird angenommen, dass $dp$ für Werte $p < p_0$ bereits richtig ist und bewiesen, dass auch die Werte für $p_0$ richtig berechnet werden. 
Angenommen, der Algoirhtmus funktioniert nicht und es gibt eine Möglichkeit, eine valide Zahl mit weniger Umlegungen als durch \ref*{eq:rek} gegben zu erstellen. 
Jede mögliche valide Zahl muss an der Stelle $p_0$ eine Ziffer zwischen 0 und F haben. Jedes valide Wort benötigt also mindestens so viele Umlegungen, wie nötig werden, um die Stelle $p_0$ zu einer Ziffer umzulegen ($\min_ {x \in [0,15]} d(w_p, x)$). 
Auch das Entfernen von Stäbchen ist eine Umlegung, sodass es jede Möglichkeit mindestens $\min_ {x \in [0,15]} d(w_p, x) + max(n,(w_p, x), 0)$ Umlegungen benötigt. 
Damit eine valide Zahl entsteht, muss nun das Wort $w_{p_0+1}, ..., w_n$ mit $e + n(w_p, x)$ mit möglichst wenig Umlegungen in eine valide Hex-Zahl umgelegt werden. Daraus folgt, dass wenn $f(p_0+1, e)$ optimal ist, es keine Möglichkeit geben kann, die weniger als $f(p, e)$ Umlegungen benötigt und $f(p, e)$ damit optimal ist. 
Das Problem hat also die sogenannte \textit{optimal substructure}.
Daraus folgt, dass nach Iteration $i$ der For-Schleife in Zeile 4 $dp[p][e]$ für $n+1 > p > n-i$ korrekt ist. 
Folglich ist $dp[p][e]$ nach allen $i = n$ Iterationen für alle $n+1 > p > 0$ und damit Algorithmus \ref*{alg:precalc} korrekt.  

Algorithmus \ref*{alg:reconstruct} kann mit einem Ähnlichen Prinzip bewiesen werden. 
Der Algorithmus soll die größte Hex-Zahl ausgeben, mit $\leq m$ Umlegungen aus dem Wort $w$ hergestellt werden kann. 
Der Beweis erfolgt über eine Invariante: Nach $p$ Durchläufen der For-Schleife gilt (1) $s$ ist die maximale Zahl, die mit den ersten $p$ Stellen gebildet werden kann, (2) $e$ ist die Anzahl der überschüssigen Stäbchen, wenn die ersten $p$ Stellen zu $s$ umgelegt werden und (3) $z$ ist die Anzahl der noch übrigen Umlegungen.
Mit $s = \epsilon$, $z = m$ und $e = 0$ gelten alle drei Bedingungen vor der ersten Iteration.

In jeder Iteration wird die größte Stelle für die Stelle $p$ zu $s$ hinzugefügt, bei der es noch möglich ist, mit den danach noch übrigen Umlegungen das Wort $w_{p+1}, ..., w_n$ mit den dann übrigen Stäbchen zu einer validen Hexzahl umzulegen. 
Die so entstandene Zahl ist die größtmögliche Zahl, die mit den ersten $p$ Stellen gebildet werden kann, da die ersten $p-1$ Stellen bereits die größtmögliche Zahl waren und der Stelle $p$ ebenfalls die größtmögliche Stelle zugewiesen wurde. 
% TODO: optimal substructure besser begründen....
Bedingung (1) ist also korrekt. Wurde eine Ziffer für Stelle $p$ ausgewählt, werden $e$ und $z$ entsprechend angepasst, sodass auch Bedingungen (2) und (3) richtig ist. 

Folglich ist $s$ nach $n$-Iterationen die maximale Zahl, die in den ersten $n$ Stellen mit höchstens $m$ Umlegungen gebildet werden kann und Algorithmus \ref*{alg:reconstruct} korrekt.
% TODO: vllt. noch begründen, warum eine stelle nie geleert wird

Es folgt der Beweis für Algorithmus \ref*{alg:reconstruct}.
Der Algorithmus erhält zwei Zahlen und soll, sofern dies möglich ist, eine Reihe von minimal vielen Umlegungen ausgebenn, um von der ersten Zahl zur zweiten zu gelangen. Außerdem soll beim durchführen dieser Umlegungen niemals eine Stelle der Zahl vollständig geleert werden. 
Zunächst wird bewiesen, dass der Algorithmus eine minimale Reiehe von Umlegungen findet, sofern diese existiert. Eine Reihe von Umlegungen existiert genau dann, wenn beide Zahlen gleich viele Stäbchen verwenden. 
Sei $e$ die Menge aller Positionen, in denen ein Stäbchen fehlt und $n$ die Menge der Positionen, in denen ein Stäbchen liegt, aber nicht liegen sollte. 
Damit eine Umlegung möglich ist, muss also $|e|= |n|$ gelten. 
Durch die Zeilen 6-11 werden alle Positionen, in denen ein Stäbchen fehlt oder hinzugefügt werden muss $e$ bzw. $n$ hinzugefügt.
% TODO: Beweis, dass minmiale Lösung gefunden wird fertig stellen

Nun bleibt zu zeigen, dass bei diesen Umlegungen eine Stelle niemals vollständig geleert wird.
Um eine Position zwischen zwei Umlegungen vollständig zu leeren müssten zuerst alle Stäbchen der Stelle in andere Stellen verschoben werden, sodass die Stelle leer werden kann, und dann die nun benötigten Stäbchen aus anderen Stellen in diese Stelle bewegt werden. 
Wenn eine Stelle komplett geeleert wird, kann es also keine Umlegung innerhalb dieser Stelle geben. 
Da alle Ziffern mindestens ein Stäbchen verwenden, ist es immer möglich, ein Stäbchen innerhalb der Ziffer umzulegen und zu verhindern, dass die Stelle vollständig geleert wird. 
In den Zeilen 5-12 werden alle fehlenden bzw. überschüssigen Stäbchen den Listen $e$ und $n$ am deren Ende hinzugefügt. 
Da der Algorithmus in den Zeilen 13-17 die fehlenden bzw. überschüssigen Stellen vom Ende der Liste verwendet, wird immer eine umlegung innerhalb der Stelle durchgeführt, sofern dies möglich ist.
Folglich wird beim Durchführen der durch den Algorithmus ausgegeben Umlegungen nie ein Zeichen vollständig geleert.  


\subsection{Erweiterungen}
\subsubsection{Kurze Wege beim Umlegen}
Nachdem Severin es nun geschafft hat, die größtmögliche Hex-Zahl zu finden, möchte die Lehrerin, dass er die Umlegungen jetzt auch auf dem Tisch ausführt. Da die Zahl aber sehr groß ist, muss er sich dabei viel hin und herbewegen. Daher sucht Severin nun eine Möglichkeit, die Umlegungen durchzuführen, und sich dabei so wenig wie möglich zu bewegen. 
Dabei kann er immer nur ein Stäbchen gleichzeitig in der Hand halten.
Gesucht ist also eine Folge von abwechselnd Positionen, an denen ein Stab übrig ist und Positionen, an denen ein Stäbchen benötigt wird, bei der die Strecke möglichst gering ist und die alle Positionen besucht. 
Jedem Stäbchen innerhalb einer Stelle wird dabei die Position des Mittelpunktes mit $x$- und $y$-Koordinate zugewiesen. 
Zum Lösen dieses Problems, welches ein spezialfall des Problems des Handlungsreisenden (TSP) ist, wird ein genetischer Algorithus verwendet. 
So wird nicht unbedingt die beste Lösung gefunden, da es sich um ein heuristisches Verfahren handelt. 
Dafür kann der Algorithmus aber auch bei sehr großen Instanzen in angemessener Zeit eine akzeptable Lösung finden. 

Evolutionäre Algorithmen sind Metaheuristiken zum Lösen von Optimierungsproblemen, die am Prozess der Evolution in der Natur inspiriert sind. 
Mögliche Lösungen werden als Individuuen einer Population dargestellt, die zu beginn aus zufälligen Lösungen besteht. 
Danach werden mehrere Generationen simuliert. 
In jeder Generation wird dann die Fitness (also Qualität) aller Individuen der Population bestimmt.
Aus den besten Individuen der letzten Generation werden dann bei der Selektion die Individuen der nächsten Generation erstellt. Dabei werden die Lösungen noch zufällig leicht verändert (Mutation), um die Mutation aus der Natur zu immitieren. 
Optional kann auch aus zwei Eltern-Individuuen durch Crossover ein Individuum der nächsten Generation erstellt werden. 
Nach einer bestimmten Anzahl an Generationen wird die beste bisher gefundene Lösung zu
Für dieses Problem werden werden mögliche Lösungen als Liste von Positionen modelliert, die Severin in dieser Reihenfolge abgehen muss. 
Bei jeder Position mit geradem Index wird ein Stäbchen aufgenommen und dann bei der nächsten Positon (mit ungeradem Index) abgelegt. 
Bei der Mutation werden dann (potentiell mehrfach) zwei gerade bzw. zwei ungerade Positonen zufällig miteinander ausgetauscht. 
Für jedes Individuum wird dann die Länge des Weges berechnet. 
Dafür wird die Summe der euklidischen Distanzen der einzelnen Wege verwendet. 
Schließlich werden alle Individuuen einer Generation sortiert.
Die Selektion findet dann nach Rang statt, da so (gegenüber z.B. Roulette-Selektion )auch kleine Unterschiede in den Längen durchsetzen können. 
Bei der Mutation muss zusätzlich noch die Bedingung beachtet werden, dass eine Stelle nie vollständig geleert werden kann.
Ist dies der Fall, wird das Individuum verworfen und eine neue Mutation durchgeführt. 
Zusätzlich wird der sogenannte Elitismus (eng. Elitsm) verwendet, um zu verhindern, dass sich die Lösungen über Generationen verschlechtern. Dafür werden die besten $n$ Individuen aus der letzten Generation ohne Mutation in die nächste übernommen. 
Außerdem werden in jeder Generation eine geringe Menge von vollständig zufällig generierten Individuuen hinzugefügt. 
Das kann dem Algorithmus helfen, aus einem lokalen Minimum zu entkommen. 
Außderdem wird der Population zu Beginn bereits die Lösung von Algorithmus \ref{alg:moves} hinzugefügt. So kann der Algorithmus diese Lösung als Ausgangspunkt verwenden und verbessern. 
In der Praxis findet der Evolutionäre Algorithmus in allen Beispielen von der BWINF-Website kürzere Umlegungen als Algorithmus \ref{alg:moves}


\subsubsection{Möglichst nah an Zielzahl}
Nun hat Severins lehrerin eine weitere Aufgabe: er soll nicht nur die größtmögliche Zahl finden, sondern eine, die Möglichst nah an einer Zielzahl liegt. Der Algorithmus kann dadurch Greedy-Bleiben, die Auswahl wird jedoch deutlich komplexer.



\section{Umsetzung}
Die Lösung wurde in \texttt{C++} implementiert. Die drei Algorithmen sind in der Klasse \lstinline{DPSolver} implementiert. Die Datei \texttt{main.cpp} liest die Argumente und Problemdefinition ein, ruft den \lstinline{DPSolver} auf und gibt das Ergebnis aus. 

Eine mögliche Belegung wird durch die Klasse \lstinline{Zustand} modelliert. 
Jede Einzelne Stelle kann effizient als \lstinline{std::bitset<7>} dargestellt werden. 
Abbildung \ref{fig:indizes} zeigt, welche Bits zu welcher Position gehören.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \draw[gray,line width = 2pt] (0.1, 0) -- (0.9, 0) node [midway, below, black] {3};
        \draw[gray,line width = 2pt] (0.1, 1) -- (0.9, 1) node [midway,above, black] {6};
        \draw[gray,line width = 2pt] (0.1, 2) -- (0.9, 2) node [midway,above,black] {0};
        \draw[gray,line width = 2pt] (0, 0.1) -- (0, 0.9)node [midway,left, black] {4};
        \draw[gray,line width = 2pt] (0, 1.1) -- (0, 1.9)node [midway,left, black] {5};
        \draw[gray,line width = 2pt] (1, 0.1) -- (1, 0.9)node [midway,right, black] {2};
        \draw[gray,line width = 2pt] (1, 1.1) -- (1, 1.9)node [midway,right, black] {1};
    \end{tikzpicture}
    \caption[]{Nummerierung der Segmente}
    \label[]{fig:indizes}
\end{figure}

Die \lstinline{Klasse} enthält außerdem Funktionen zur Ein- und Ausgabe von Zuständen. Beim Einlesen müssen Hex-Ziffern in Belegungen der sieben Segmente umgewandelt werden. Dazu wird die Tabelle \lstinline{STAEBCHEN} verwendet, die für jede Ziffer die Belegung, als Hex-Wert encodiert, enthält. 
Durch Suchen der Belegungen in \lstinline{STAEBCHEN} kann ein Zustand zurück in eine normale Hex-Zahl umgewandelt werden. 
Für die Ausgabe der Zwischenzustände ist es allerdings nötig, auch Zustände auszugeben, die sich aktuell nicht in eine normale Hex-Zahl umwandeln lassen.
Um diese dennoch im Terminal ausgeben zu können werden die Rahmenzeichen des Unicode-Zeichensatzes verwendet, um alle sieben Segmente kompakt darstellen zu können.
Die Methoden \lstinline{visualisiereZahl()} und \lstinline{visualisiereZiffer} stellen eine Ziffer bzw. eine ganze Zahl über Rahmenzeichen dar. 
Die Funktion \lstinline{visualisiereZiffer} gibt die drei Zeilen der Ziffer als einzelne Strings zurück, sodass mehrere Ziffern aneinandergefügt werden können.
Die Methode \lstinline{visualisiereUmlegungen} visualisiert dann alle Zwischenzustände, die entstehen, wenn man die gegenenen Umlegungen durchführt. Zusätzlich werden Linien hinzugefügt, die zeigen, von welcher Stelle zu welcher Stelle das Stäbchen bewegt wurde. 

Nun zur Implementation des eigentlichen Lösungsverfahrens. 
Die \lstinline{solve()}-Funktion  der Klasse \lstinline{DPSolver} initialisiert die Variablen und ruft dann die Methoden \lstinline{dpVorberechen()} und \lstinline{rekonstruiere()}  auf, die Algorithmus \ref*{alg:precalc} bzw. Algorithmus \ref{alg:reconstruct} implementieren.
Als Memoization-Tabelle wird ein Vektor verwendet, die Funktion \lstinline{memoKey(int pos, int d)} gibt an an, an welcher Position im Vektor ein Wert gespeichert ist. 
Zusätzlich wird die Funktion \lstinline{getMemo} verwendet, um auf die Werte im \lstinline{memo}-Vektor zuzugreifen. 
So kann gewährleistet werden, dass für Werte, die zu viele Umlegungen verwenden $\infty$ zurückgegeben wird, ohne diese Werte extra zu speichern. 
Die Funktion \lstinline{unterschied(x1, x2)} gibt sowohl $d(x_1, x_2)$ als auch $n(x_1, x_2)$ in einem \lstinline{std::pair<int, int>} zurück. 
Ansonsten folgt die Implementation der beiden Funktionen dem oben beschriebenen Pseudocode. 
Algorithmus \ref{alg:moves} ist in \lstinline{getMoves()} implementiert. 
Die Umlegungen werden als Vektor von Paaren von Positionen zurückgegeben.
Eine Position ist dabei ebenfalls ein Paar, der erste Wert gibt die Stelle und der zweite Wert die Positon innerhalb der Stelle nach Abbildung \ref{fig:indizes} an.
\section{Beispiele}
Genügend Beispiele einbinden! Die Beispiele von der BwInf-Webseite sollten hier diskutiert werden, aber auch eigene Beispiele sind sehr gut – besonders wenn sie Spezialfälle abdecken. Aber bitte nicht 30 Seiten Programmausgabe hier einfügen!

\section{Quellcode}
Unwichtige Teile des Programms sollen hier nicht abgedruckt werden. Dieser Teil sollte nicht mehr als 2–3 Seiten umfassen, maximal 10.



\end{document}
