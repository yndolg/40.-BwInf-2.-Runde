\documentclass[a4paper,10pt,ngerman]{scrartcl}

\input{preamble.tex}

\begin{document}

\maketitle
\tableofcontents

\section{Lösungsidee}
\subsection{Modellierung}
Gegeben ist ein Wort $w$ aus den Hex-Ziffern $x_1, x_2, ..., x_n$, die jeweils eine Stelle der Hexadezimalzal beschreiben, und eine maximale Zahl an Umlegungen $m$. 
Jedes Zeichen ist ein 7-Tupel, welches für jedes Segment im Zeichen angibt, ob es belegt oder frei ist.

Gesucht ist nun das größte solche Wort, was sich mit maximal $m$ Umlegungen aus $w$ legen lässt.

\subsection{Lösung}
Das Problem kann mittels dynmischer Programmierung und einem anschließenden Greedy-Algorithmus gelöst werden. 
Sei
\begin{align}
    f(p, e)
\end{align}
die Anzahl der Umlegungen, die mindestens benötigt werden, um insgesamt $e$ zusätliche Positionen im Teilwort $w_p, ..., w_n$ zu besetzten und eine valide Zahl zu erhalten. Die Zahl $e$ kann auch negativ sein, was bedeutet, dass Stäbchen von $e$ Positionen entfernt werden sollen. Dabei zählt nur das entfernen von Stäbchen aus dem Teilwort als Umlegung. Ist $e$ also positiv, so können diese Stäbchen ohne als Umlegung zu zählen abgelegt werden. Ist $e$ allerding negativ, so zählt das nehmen der $e$ Stäbchen als Umlegung. Diese Konvention wird im Folgenden für alle Umlegungen verwendet.

Ist $f(p, e)$ für alle $p$ und $e$ bekannt, kann das maximale Wort über ein Greedy-Verfahren rekonstruiert werden. 
$f(p, e)$ kann über dynamische Programmierung effizient berechnet werden. 

Sei dazu $d(x,y)$ die Anzahl der Umlegungen um die Ziffer $x$ in die Ziffer $y$ umzuwandeln. Für entfernte bzw. hinzugefügte Stäbchen gilt die oben beschriebene Konvention. 
$n(x, y)$ ist analog dazu die Anzahl der Stäbchen, die entfernt bzw. hinzugefügt werden müssen, um $x$ in $y$ umzuwandeln. Abbildung \ref{fig:n_d_examples} zeigt ein Beispiel für von $d(x,y)$ und $n(x,y)$.
Beide Werte können einfach aus den Segmenten für die Ziffern bestimmt werden.
\begin{figure}
    \centering
    \begin{tikzpicture}
        \draw[black,line width = 2pt] (0.1, 0) -- (0.9, 0) ;
        \draw[black,line width = 2pt] (0.1, 1) -- (0.9, 1);
        \draw[black,line width = 2pt] (0.1, 2) -- (0.9, 2) ;
        \draw[gray!50,line width = 2pt] (0, 0.1) -- (0, 0.9) ;
        \draw[black,line width = 2pt] (0, 1.1) -- (0, 1.9);
        \draw[black,line width = 2pt] (1, 0.1) -- (1, 0.9);
        \draw[gray!50,line width = 2pt] (1, 1.1) -- (1, 1.9);
        

        \draw[->] (1.5, 1) -- (2.5,1);
        \begin{scope}[shift={(3, 0)}]
            \draw[gray!50,line width = 2pt] (0.1, 0) -- (0.9, 0) ;
        \draw[black,line width = 2pt] (0.1, 1) -- (0.9, 1);
        \draw[gray!50,line width = 2pt] (0.1, 2) -- (0.9, 2) ;
        \draw[gray!50,line width = 2pt] (0, 0.1) -- (0, 0.9) ;
        \draw[black,line width = 2pt] (0, 1.1) -- (0, 1.9);
        \draw[black,line width = 2pt] (1, 0.1) -- (1, 0.9);
        \draw[black,line width = 2pt] (1, 1.1) -- (1, 1.9);
        \end{scope}
    \end{tikzpicture}
    \caption[]{Umlegung der Ziffer 5 zur Ziffer 4. $d(5,4) = 1$, da ein Stab umgelegt werden muss. $n(5, 4) = -1$, da ein Stab entfernt werden muss. Der entfernte Stab zählt nicht als Umlegung. Müsste aber, ein Stab hinzugefügt werden, so würde dieser als Umlegung zählen. $d(4,5)$ wäre also $2$. }
    \label[]{fig:n_d_examples}
\end{figure}
Nun gilt die Rekurrenz
\begin{align}
    f(p, e) = \min_{x\in [0, 15]} f(p + 1, e + n(w_p, x)) + d(w_p, x). \label{eq:rek}
\end{align}

Die aktuelle Stelle $p$ kann zu einer den Hex-Ziffern 0--F umgewandelt werden. Dafür werden $d(w_p, x)$ Umlegungen benötigt. Dazu werden die Umlegungen addiert, die noch benötigt werden, um die $n(w_p, x)$ frei gewordenen Stäbchen im Rest des Wortes zu integrieren.
Hier wird klar, warum für einzelne Zeichen nur herausgenommene Stäbchen als Umlegunge gezählt werden, nicht aber hinzugefügte: so werden Umlegungen zwischen Ziffern nur in der Ursprungsziffer und nicht in der Zielziffer gezählt.
Schließlich wird das Minimum über alle möglichen Zeichen an der Position $p$ verwendet. 

Mit der Rekurrenz \ref{eq:rek} kann $f(p, e)$ für alle möglichen Werte bottom-up vorberechnet werden, wie in Algorithmus \ref{alg:precalc} dargestellt.
% TODO: vllt noch base-case erläutern
\begin{algorithm}
\caption{Berechnung von $f$}
\label{alg:precalc}
\begin{algorithmic}[1]
    \Procedure{Vorberechnen}{$w, m$}
    \State sei $dp[1, ..., n+1][-m, ..., m]$ ein neues Array
    \State $dp[n+1][-m, ..., m] \gets \begin{cases}
        0 & \text{, falls } m = 0\\
        \infty &\text{, falls } m \neq 0
    \end{cases}$ \Comment{Initialisen der Basisfälle, das leere Wort}
    \For {$p \gets n, ..., 1$}
        \For {$e \gets -m, ..., m$}
            \State{$dp[p][e] \gets \min_{x\in [0, 15]} f(p + 1, e + n(w_p, x)) + d(w_p, x)$}
        \EndFor 
    \EndFor
    \State \textbf{return} $dp$
\EndProcedure
\end{algorithmic}
\end{algorithm} 

Ist $f(p, e)$ bekannt, kann die größte Zahl greedy rekonstruiert werden. Dazu wird an jeder Stelle, von links nach rechts, die größte Ziffer verwendet, bei der die dann benötigten Umlegungen die Grenze noch nicht überschreitet. Dieses Vorgehen ist in Algorithmus \ref{alg:reconstruct} dargestellt.
\begin{algorithm}
    \caption{Rekonstruktion der maximalen Zahl}
    \label[]{alg:reconstruct}
    \begin{algorithmic}[1]
        \Procedure{Rekonstruktion}{$w, f$}
            \State $e \gets 0$ \Comment{aktuell überschüssige Stäbe}
            \State $z \gets m$ \Comment{noch übrige Umlegungen}
            \State $s \gets \epsilon$  \Comment{das rekonstruierte Wort}
        \For{$p \gets 1,...,n$}
            \For{$x \gets F,...,0$}
                \If{$f(p + 1, e + n(w_p, x)) + d(w_p) \leq z$}
                    \State $e \gets e + n(w_p, x)$
                    \State $s \gets s + x$
                    \State $z \gets z - d(w_p)$
                    \State \textbf{break}
                \EndIf
            \EndFor
        \EndFor
        \State \textbf{return} $s$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
Nun ist die größte Zahl gefunden, in der Aufgabenstellung ist jedoch weiterhin gefordert, die Zwischenstände nach jeder Umlegung auszugeben.
Dafür muss eine Folge von konkreten Umlegungen gefunden werden, um vom Eingabewort zum Ergebnis zu gelangen. 
Ferner ist gefordert, dass während den Umlegungen ein Zeichen niemals vollständig geleert werden darf. 
Die Grundidee dafür ist es, alle Positionen zu finden, in denen ein Stäbchen benötigt bzw. überflüssig ist. 
Daraufhin muss immer ein Stäbchen von einer überflüssigen zu einer benötigten Position bewegt werden. 
Da es genau so viele Positionen gibt, in denen ein Stäbchen benötigt wird, wie in denen ein Stäbchen überflüssig ist, ist es prinzipiell egal, welches Stäbchen wohin und in welcher Reihenfolge bewegt wird, forausgesetzt es wird immer ein überschüssiges Stäbchen zu einer benötigten Position umgelegt.
Es wird immer die gleiche Anzahl an Umlegungen benötigt. 
Allerdings muss darauf geachtet werden, dass keine Stelle zu einem Zeitpunkt vollständig geleert wird. 
\begin{algorithm}
    \caption{Finden der Umlegungen}
    \label[]{alg:moves}
    \begin{algorithmic}[1]
        \Procedure{Umlegen}{$w_1, w_2$}
            \State $e \gets []$ \Comment{Positionen mit überschüssigem Stäbchen}
            \State $n \gets []$ \Comment{Positionen, die ein Stäbchen benötigen}
        \For{$z \gets 1,..,n$} \Comment{über alle Zeichen iterieren}
            \For{$i \gets 0,...,6 $} \Comment{über die sieben Segmente iterieren}
                \If{Segment $i$ von Zeichen $z$ muss gesestzt werden}
                    \State $n$.push($(z, i)$)
                \EndIf
                \If{Segment $i$ von Zeichen $z$ muss entfernt werden}
                    \State $e$.push($(z, i)$)
                \EndIf
            \EndFor
            \While{$e.\text{size()} > 0$ und $n.\text{size()} > 0$}
                \State $a \gets e$.pop()
                \State $b \gets n$.pop()
                \State bewege Stäbchen von $a$ nach $b$
            \EndWhile
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
Algorithmus \ref{alg:moves} findet die Positionen, an denen ein Stäbchen überflüssig bzw. benötigt ist und fügt diese Positionen zu Listen hinzu. Nach jedem Zeichen wird jeweils ein benötigtes Stäbchen und ein überschüssiges Stäbchen aus den Listen entfernt und das Stäbchen bewegt. Dadurch wird sichergestellt, dass ein Zeichen niemals vollständig geleert werden kann, ohne die Laufzeit von $\Theta(n)$ zu verschlechtern. Der Beweis dafür folgt unter \ref{sec:prove}.

\subsection{Analyse der Laufzeit}
Zunächst wird die Laufzeit von Algorithmus \ref{alg:precalc} analysiert.
Die Initialisierung des Arrays in Zeile 2 und 3 benötigt $T(n, m) = \Theta(n (2m+1)) + \Theta(m) = \Theta(n \cdot m)$ Laufzeit.
Zeile 6 benötigt eine Laufzeit von $\Theta(1)$, da der Ausdruck 15 Mal mit jeweils konstanter Laufzeit ausgewertet wird, unabhängig von $n$ und $m$.
Diese Zeile wird durch die beiden for-Schleifen $n(2m+1)$-Mal ausgeführt. 
So ergibt sich eine Gesamtlaufzeit von 
\begin{align*}
    T(n, m) &= \Theta(n \cdot m) + n(2m+1) \cdot \Theta(1)\\
    T(n, m) &= \Theta(nm)
\end{align*}

Nun wird die Laufzeit von Algorithmus \ref{alg:reconstruct} analysiert.
Die Zeilen 2--4 benötigen insgesamt $T(n) = \Theta(1)$ Laufzeit. 
Die for-Schleife in Zeile 5 wird $n$-Mal ausgeführt, die for-Schleife in Ziele 6 wird maximal 15-Mal ausgeführt und die Zeilen 7-12 benötigen insgesamt $T(n,m) = \Theta(1)$ Laufzeit. 
So ergibt sich für Algorithmus \ref{alg:reconstruct} eine Laufzeit von 
\begin{align*}
    T(n,m) &= n \cdot O(15) \cdot \Theta(1)\\
    T(n, m) &= n \cdot \Theta(1) \cdot \Theta(1)\\
    T(n, m) &= \Theta(n)
\end{align*}

Algorithmus \ref{alg:moves} hat wie bereits erwähnt eine Laufzeit von $T(n) = \Theta(n)$. Die Zeilen 2 und 3 benötigen $\Theta(1)$ Zeit und werden nur einmal ausgeführt. 
Die for-Schleife aus Zeile 4 wird $n$-Mal ausgeführt. 
Die Zeilen 5-12 benötigen pro Ausführung $\Theta(1)$ Laufzeit, da die for-Schleife in Zeile 5 immer 7-Mal ausgeführt wird und jeweils eine konstante Laufzeit pro Iteration hat. 

Die while-Schleife in Zeile 13 wird während des gesamten Algorithmus nicht öfter als $7n$-Mal aufgerufen, da jedes Segment nur einmal in die Listen eingefügt (und folglich auch herausgenommen) werden kann. Die Zeilen 13-17 benötigen also über alle Iterationen $O(n)$ Laufzeit.
Die Gesamtlaufzeit von Algorithmus \ref{alg:moves} ist also 
\begin{align*}
    T(n) &= n \cdot \Theta(1) + O(n)\\
    T(n) &= \Theta(n).
\end{align*}
Die drei Algorithmen haben zusammen eine Laufzeit von 
\begin{align*}
    T(n, m) &= \Theta(n) + \Theta(nm) + \Theta(n)\\
    T(n, m) &= \Theta(nm).
\end{align*}
Die Laufzeit des Lösungsverfahren wächst also asymptotisch linear zur Länge des Wortes und zur Maximalzahl der Umlegungen. 
Da auch der konstante Faktor relativ gering ist, reicht die Laufzeit auch zum Lösen von sehr großen Instanzen.

\subsection{Analyse des Speicherbedarfs}
Das $dp$-Array von Algorithmus \ref{alg:precalc}benötigt insgesamt $n \cdot (2m + 1) = \Theta(nm)$ Speicher. Zusammen mit den Variablen $p, e$ und $x$ ergibt sich ein Speicherbedarf von $\Theta(nm) + \Theta(1) = \Theta(nm)$.

Die Rekonstruktion verwendet lediglich die Ganzzahlen $e, p, z$ und $x$, die einen Speicherbedarf von $\Theta(1)$ haben. Der String $s$ wird genauso lang wie das Eingabewort und benötigt daher $\Theta(n)$ Speichereinheiten. 
Insgesamt hat Algorithmus \ref{alg:reconstruct} also einen Speicherbedarf von $\Theta(1) + \Theta(n) = \Theta(n)$.

Algorithmus \ref{alg:moves} verwendet zwei Listen. Da jedes Segment nur maximal einemal in eine der Listen eingefügt wird, können diese Zusammen niemals mehr als $7n \in O(n)$ Speicher benötigen. 
Die drei Algorithmen haben zusammen einen Speicherbedarf von $\Theta(n) + \Theta(nm) + O(n)= \Theta(nm)$.

Damit wächst auch der Speicherbedarf linear mit der Anzahl der Stellen und Anzahl der Umlegungen. 
Wie bei der dynamischen Programmierung üblich wird hier ein etwas höherer Speicherbedarf für eine deutlich verkürze Laufzeit in Kauf genommen.
\subsection{Beweis der Richtigkeit}
\label[]{sec:prove}
Zunächst wird die Richtigkeit von Algorithmus \ref*{alg:precalc} per Induktion bewiesen.
Zur Erinnerung: $dp[p_0][e]$ soll die minimale Anzahl an Umlegungen sein, die benötigt werden, um aus dem Teilwort $w_{p_0}, ..., w_n$ und $e$ zusätzlichen Stäbchen eine valide Zahl zu erhalten.  
In Zeile 3 werden die Werte für $n+1$, also das leere Wort gesetzt. Soll kein weiteres Stäbchen verwendet werden, so ist das leere Wort eine valide Zahl und es werden keine weiteren Umlegungen verwendet. 
Sollen jedoch weitere Stäbchen verwendet werden, ist es nicht möglich, eine valide Zahl zu bilden, weil es laut Aufgabenstellung nicht erlaubt ist, weitere Stellen zu verwenden. Daher werden $\infty$ Umlegungen benötigt. Die Werte für $p_0 = n+1$ sind also korrekt, was der Induktionsanfang ist. 

Für den Induktionsschritt wird angenommen, dass $dp$ für Werte $p > p_0$ bereits richtig ist und bewiesen, dass auch die Werte für $p_0$ richtig berechnet werden. 
Angenommen, der Algorithmus funktioniert nicht und es gäbe eine Möglichkeit, eine valide Zahl mit weniger Umlegungen als durch \ref{eq:rek} gegeben zu erstellen. 
Jede mögliche valide Zahl muss an der Stelle $p_0$ eine Ziffer zwischen 0 und F haben. Jedes valide Wort benötigt also mindestens so viele Umlegungen, wie nötig werden, um die Stelle $p_0$ zu einer Ziffer umzulegen ($\min_ {x \in [0,15]} d(w_p, x)$). 
Damit eine valide Zahl entsteht, muss nun das Wort $w_{p_0+1}, ..., w_n$ mit $e + n(w_p, x)$ zusätzlichen Stäbchen mit möglichst wenig Umlegungen in eine valide Hex-Zahl umgelegt werden. Daraus folgt, dass wenn $f(p_0+1, e + n(w_p, x))$ optimal ist, es keine Möglichkeit geben kann, die weniger als $f(p_0, e)$ Umlegungen benötigt und $f(p_0, e)$ damit optimal ist. 
Das Problem hat also die sogenannte \textit{optimal substructure}.
Daraus folgt per Induktion über $n$, dass nach Iteration $i$ der äußeren for-Schleife $dp[p][e]$ für $n-i \leq p \leq n+1 $ korrekt ist. 
Folglich ist $dp[p][e]$ nach allen $i = n$ Iterationen für alle $0 \leq p \leq n+1 $, und damit Algorithmus \ref*{alg:precalc}, korrekt.  

Die Richtigkeit von Algorithmus \ref*{alg:reconstruct} kann mit einem ähnlichen Prinzip begründet werden. 
Der Algorithmus soll die größte Hex-Zahl ausgeben, die mit $\leq m$ Umlegungen aus dem Wort $w$ hergestellt werden kann. 
Der Beweis erfolgt über eine Invariante: Nach $p$ Durchläufen der äußeren for-Schleife gilt (1) $s$ ist die maximale Zahl, die mit den ersten $p$ Stellen gebildet werden kann, (2) $e$ ist die Anzahl der überschüssigen Stäbchen, wenn die ersten $p$ Stellen zu $s$ umgelegt werden und (3) $z$ ist die Anzahl der noch übrigen Umlegungen.
Mit $s = \epsilon$, $z = m$ und $e = 0$ gelten alle drei Bedingungen vor der ersten Iteration.

In jeder Iteration wird die größte Stelle für die Stelle $p$ zu $s$ hinzugefügt, bei der es noch möglich ist, mit den danach noch übrigen Umlegungen das Wort $w_{p+1}, ..., w_n$ mit den dann übrigen Stäbchen zu einer validen Hexzahl umzulegen. 
Die so entstandene Zahl ist die größtmögliche Zahl, die mit den ersten $p$ Stellen gebildet werden kann, da die ersten $p-1$ Stellen bereits die größtmögliche Zahl waren und der Stelle $p$ ebenfalls die größtmögliche Stelle zugewiesen wurde. 

Dies kann über einen Wiederspruchsbeweis gezeigt werden: gäbe es eine größere Zahl als die gefundene, so müsste diese entweder eine größere Zahl in den ersten $p-1$ Stellen oder an der Stelle $p$ haben. Beides ist aber bereits maximal. Folglich kann es keine größere Zahl geben, die die ersten $p$ Stellen verwendet. Auch dieses Problem hat \textit{optimal substructure}.

Bedingung (1) ist also auch nach einem Durchlauf der Schleife noch korrekt. Wurde eine Ziffer für Stelle $p$ ausgewählt, werden $e$ und $z$ entsprechend angepasst, sodass auch die Bedingungen (2) und (3) weiter zutreffen. 

Folglich ist $s$ nach $n$-Iterationen die maximale Zahl, die in den ersten $n$ Stellen mit höchstens $m$ Umlegungen gebildet werden kann und Algorithmus \ref*{alg:reconstruct} korrekt.
% TODO: vllt. noch begründen, warum eine stelle nie geleert wird

Es folgt der Beweis für Algorithmus \ref*{alg:moves}.
Der Algorithmus erhält zwei Zahlen und soll, sofern dies möglich ist, eine Reihe von minimal vielen Umlegungen ausgeben, um von der ersten Zahl zur zweiten zu gelangen. Außerdem soll beim Durchführen dieser Umlegungen niemals eine Stelle der Zahl vollständig geleert werden. 
Zunächst wird bewiesen, dass der Algorithmus eine minimale Reihe von Umlegungen findet, sofern diese existiert. Eine Reihe von Umlegungen existiert genau dann, wenn beide Zahlen gleich viele Stäbchen verwenden. 
Sei $e$ die Menge aller Positionen, in denen ein Stäbchen fehlt und $n$ die Menge der Positionen, in denen ein Stäbchen liegt, aber nicht liegen sollte. 
Damit eine Umlegung möglich ist, muss also $|e| = |n|$ gelten. 
Durch die Zeilen 6-11 werden alle Positionen, in denen ein Stäbchen fehlt oder hinzugefügt werden muss währen des Algorithmus $e$ bzw. $n$ hinzugefügt.
Die while-Schleife entfernt dann immer ein Element aus beiden Mengen, sofern dies möglich ist. 
Da $|e| = |n|$, werden  alle Elemente aus den Listen wieder entfernt und umgelegt und $|e| = |n|$, also die minimale Anzahl, viele Stäbchen bewegt. 

Nun bleibt zu zeigen, dass bei diesen Umlegungen eine Stelle niemals vollständig geleert wird.
Um eine Position zwischen zwei Umlegungen vollständig zu leeren, müssten zuerst alle Stäbchen der Stelle in andere Stellen verschoben werden, sodass die Stelle leer werden kann, und dann die nun benötigten Stäbchen aus anderen Stellen in diese Stelle bewegt werden. 
Wenn eine Stelle komplett geeleert wird, kann es also keine Umlegung innerhalb dieser Stelle geben. 
Es ist immer möglich ein Stäbchen innerhalb der Ziffer umzulegen, um zu verhindern, dass die Stelle vollständig geleert wird. Eine Außname ist, wenn in einer Stelle nur Stäbchen entfernt bzw. hinzugefügt werden müssen. In diesem Fall kann die Stelle aber auch nicht geleert werden, da keine Hex-Ziffer leer ist. 
In den Zeilen 5-12 werden alle fehlenden bzw. überschüssigen Stäbchen den Listen $e$ und $n$ an deren Ende hinzugefügt. 
Da der Algorithmus in den Zeilen 13-17 die fehlenden bzw. überschüssigen Stellen vom Ende der Liste verwendet, wird immer eine Umlegung innerhalb der Stelle durchgeführt, sofern dies möglich ist.
Folglich wird beim Durchführen der durch den Algorithmus ausgegeben Umlegungen nie ein Zeichen vollständig geleert und auch Algorithmus \ref{alg:moves} ist korrekt.

\subsection{Erweiterungen}
\subsubsection{Kurze Wege beim Umlegen}
Nachdem Severin es geschafft hat, die größtmögliche Hex-Zahl zu finden, möchte die Lehrerin, dass er die Umlegungen jetzt auch auf dem Tisch ausführt. Da die Zahl aber sehr lang ist, muss er sich dabei viel hin und herbewegen. Daher sucht Severin nun eine Möglichkeit, die Umlegungen durchzuführen und sich dabei so wenig wie möglich zu bewegen. 
Er kann immer nur ein Stäbchen gleichzeitig in der Hand halten.
Gesucht ist also eine Folge von abwechselnd Positionen, an denen ein Stab übrig ist und Positionen, an denen ein Stäbchen benötigt wird, bei der die Strecke Abstände zwischen benachbarten Positionen möglichst gering sind und alle Positionen besucht werden.
Jedem Stäbchen wird dabei die Position des Mittelpunktes mit $x$- und $y$-Koordinate zugewiesen. 

Zum Lösen dieses Problems, welches ein Spezialfall des Problem des Handlungsreisenden (TSP) ist, wird ein evolutionärer Algorithus verwendet. 
Dieser findet nicht unbedingt die beste Lösung, da es sich um ein heuristisches Verfahren handelt, dafür kann der Algorithmus aber auch bei sehr großen Instanzen in angemessener Zeit eine akzeptable Lösung finden. 

Evolutionäre Algorithmen sind Metaheuristiken zum Lösen von Optimierungsproblemen, die am Prozess der Evolution in der Natur inspiriert sind. 
Mögliche Lösungen werden als Individuen einer Population dargestellt, die zu Beginn aus zufälligen Lösungen besteht. 
Danach werden mehrere Generationen simuliert. 
In jeder Generation wird die Fitness (also Qualität) aller Individuen der Population bestimmt.
Aus den besten Individuen der letzten Generation werden dann bei der Selektion die Individuen der nächsten Generation erstellt. 
Dabei werden die Lösungen noch leicht zufällig verändert (Mutation), um sich schrittweise einer besseren Lösung annähern zu können.
Optional kann auch aus zwei Eltern-Individuen durch Crossover ein Individuum der nächsten Generation erstellt werden. 
Nach einer bestimmten Anzahl an Generationen wird die beste bisher gefundene Lösung zurückgegeben.

Für dieses Problem werden werden mögliche Lösungen als Liste von Positionen modelliert, die Severin in dieser Reihenfolge abgehen muss. 
Bei jeder Position mit geradem Index wird ein Stäbchen aufgenommen und dann bei der nächsten Positon (mit ungeradem Index) abgelegt. 
Bei der Mutation werden dann (potentiell mehrfach) zwei gerade bzw. zwei ungerade Positonen zufällig miteinander ausgetauscht. 
Für jedes Individuum wird die Länge des Weges berechnet, indem die Summe der euklidischen Distanzen zwischen den in der Lösung benachbarten Positonen berechnet wird.
Schließlich werden alle Individuen einer Generation sortiert und die besten Selektiert.
Die Selektion findet nach Rang statt, da sich so (gegenüber z.B. der Roulette-Selektion) auch kleine Unterschiede in den Längen durchsetzen können. 
Bei der Mutation muss zusätzlich noch die Bedingung beachtet werden, dass eine Stelle nie vollständig geleert werden kann.
Ist dies der Fall, wird das Individuum verworfen und eine neue Mutation durchgeführt. 
Zusätzlich wird der sogenannte Elitismus (eng. Elitsm) verwendet, um zu verhindern, dass sich die Lösungen über Generationen verschlechtern. 
Das heißt, dass die besten $n$ Individuen aus der letzten Generation ohne Mutation in die nächste übernommen werden. 
Außerdem werden in jeder Generation eine geringe Menge von vollständig zufällig generierten Individuen hinzugefügt, was dem Algorithmus helfen kann, aus einem lokalen Minimum zu entkommen. 
Die Population enthält zu Beginn bereits die Lösung von Algorithmus \ref{alg:moves}. So kann der evolutionäre Algorithmus diese Lösung als Ausgangspunkt verwenden und verbessern. 
In der Praxis findet dieser evolutionäre Algorithmus in allen Beispielen von der BWINF-Website etwas kürzere Umlegungen als Algorithmus \ref{alg:moves}.


\subsubsection{Möglichst nah an Zielzahl}
Nun hat Severins lehrerin eine weitere Aufgabe: er soll nicht nur die größtmögliche Zahl finden, sondern eine, die Möglichst nah an einer Zielzahl liegt. Der Algorithmus kann dadurch Greedy-Bleiben, die Auswahl wird jedoch deutlich komplexer.
% TODO?



\section{Umsetzung}
Die Lösung wurde in \texttt{C++} implementiert. Die drei Algorithmen sind in der Klasse \lstinline{DPSolver} implementiert. Die Datei \texttt{main.cpp} liest die Argumente und Problemdefinition ein, ruft den \lstinline{DPSolver} auf und gibt das Ergebnis aus. 

Eine mögliche Belegung wird durch die Klasse \lstinline{Zustand} modelliert. 
Jede einzelne Stelle wird kompakt als \lstinline{std::bitset<7>} dargestellt. 
Abbildung \ref{fig:indizes} zeigt, welche Bits zu welcher Position gehören.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \draw[gray,line width = 2pt] (0.1, 0) -- (0.9, 0) node [midway, below, black] {3};
        \draw[gray,line width = 2pt] (0.1, 1) -- (0.9, 1) node [midway,above, black] {6};
        \draw[gray,line width = 2pt] (0.1, 2) -- (0.9, 2) node [midway,above,black] {0};
        \draw[gray,line width = 2pt] (0, 0.1) -- (0, 0.9)node [midway,left, black] {4};
        \draw[gray,line width = 2pt] (0, 1.1) -- (0, 1.9)node [midway,left, black] {5};
        \draw[gray,line width = 2pt] (1, 0.1) -- (1, 0.9)node [midway,right, black] {2};
        \draw[gray,line width = 2pt] (1, 1.1) -- (1, 1.9)node [midway,right, black] {1};
    \end{tikzpicture}
    \caption[]{Nummerierung der Segmente}
    \label[]{fig:indizes}
\end{figure}

Die \lstinline{Zustand}-Klasse enthält außerdem Funktionen zur Ein- und Ausgabe von Zuständen. Beim Einlesen müssen Hex-Ziffern in Belegungen der sieben Segmente umgewandelt werden. Dazu wird die Tabelle \lstinline{STAEBCHEN} verwendet, die für jede Ziffer die Belegung, als Hex-Wert encodiert, enthält. 
Durch Suchen der Belegungen in \lstinline{STAEBCHEN} kann ein Zustand zurück in eine Hex-Zahl umgewandelt werden. 
Für die Ausgabe der Zwischenzustände ist es allerdings nötig, auch Zustände auszugeben, die sich aktuell nicht in eine Hex-Zahl umwandeln lassen.
Um diese dennoch in der Befehlszeile ausgeben zu können werden die Rahmenzeichen des Unicode-Zeichensatzes verwendet, um platzsparend alle sieben Segmente einzeln darstellen zu können.
Die Methoden \lstinline{visualisiereZiffer()} und \lstinline{visualisiereZahl()} stellen eine Ziffer bzw. eine ganze Zahl über Rahmenzeichen dar. 
Dabei ist jede Ziffer drei Zeilen hoch.
Die Funktion \lstinline{visualisiereZiffer()} gibt die drei Zeilen der Ziffer als einzelne Strings zurück, sodass mehrere Ziffern aneinandergefügt werden können.
Die Methode \lstinline{visualisiereUmlegungen()} visualisiert dann alle Zwischenzustände, die entstehen, wenn man die gegebenen Umlegungen nacheinander durchführt. Zusätzlich werden Linien hinzugefügt, die zeigen, von welcher Stelle zu welcher Stelle das Stäbchen bewegt wurde. 

Nun zur Implementation des eigentlichen Lösungsverfahrens. 
Die \lstinline{solve()}-Funktion  der Klasse \lstinline{DPSolver} initialisiert die Variablen und ruft dann die Methoden \lstinline{dpVorberechen()} und \lstinline{rekonstruiere()}  auf, die Algorithmus \ref*{alg:precalc} bzw. Algorithmus \ref{alg:reconstruct} implementieren.
Als Memoization-Tabelle wird ein Vektor verwendet, die Funktion \lstinline{memoKey(int pos, int d)} gibt an an, an welcher Position im Vektor ein Wert gespeichert ist. 
Zusätzlich wird die Funktion \lstinline{getMemo()} verwendet, um auf die Werte im \lstinline{memo}-Vektor zuzugreifen. 
So kann gewährleistet werden, dass für Werte, die zu viele Umlegungen verwenden $\infty$ zurückgegeben wird, ohne diese Werte extra zu speichern. 
Die Funktion \lstinline{unterschied(x1, x2)} gibt sowohl $d(x_1, x_2)$ als auch $n(x_1, x_2)$ in einem \lstinline{std::pair<int, int>} zurück. 
Ansonsten folgt die Implementation der beiden Funktionen dem oben beschriebenen Pseudocode. 
Algorithmus \ref{alg:moves} ist in \lstinline{getMoves()} implementiert. 
Die Umlegungen werden als Vektor von Paaren von Positionen zurückgegeben.
Eine Position ist dabei ebenfalls ein Paar, der erste Wert gibt die Stelle und der zweite Wert die Positon innerhalb der Stelle nach Abbildung \ref{fig:indizes} an.

Zum Compilieren des Codes wird ein \texttt{C++-17}-fähiger Compiler benötigt.
Als Build-System wird CMake verwendet, der Code kann wie üblich über 
\begin{lstlisting}[language=bash]
    mkdir build
    cd build
    cmake ..
    cmake --build . 
\end{lstlisting}    
kompiliert und dann mit \lstinline[language=bash]{./hexmax [-v <Algorithmus>] <Dateipfad>} ausgeführt werden. Der Pfad sollte auf die zu lösende Eingabedatei zeigen. Der Code wurde unter Ubuntu 20.04. getestet.

\subsection{Erweiterung: Kurze Wege beim Umlegen}
Der Algorithmus zum Finden von Umlegungen, bei denen sich möglichst wenig bewegt werden muss ist in der Klasse \lstinline{TSPSolver} implementiert. In der \lstinline{solve()}-Funktion findet sich der eigentliche Algorithmus. 
Ein Individuum ist, wie bei der Lösungsidee beschreiben, eine Liste von Positionen, bei denen abwechselnd ein Stäbchen aufgenommen bzw. abgelegt wird. 
Eine Position ist, wie beim Greedy-Algorithmus, ein \lstinline{std::pair<int, int>}, das sowohl die Stelle als auch die Position innerhalb der Stelle speichert. 
In der \lstinline{length()}-Funktion wird die Länge des Weges für eine mögliche Lösung berechnet. 
Dafür werden die Strecken zwischen den Segmenten addiert. 
Um die Strecken genau berechnen zu können, ist es wichtig, die Positionen der Stäbchen in einem Koordinatensystem festzulegen. 
Dafür wird jeweils der Mittelpunkt der Segmente verwendendet und die Zeichen sind eine Längeneinheit breit und zwei Längeneinheiten hoch.
Im \lstinline{POSITIONS}-Vektor sind die $x$- und $y$-Koordinaten der Segmente gespeichert. 
Die eigentliche Distanz zwischen zwei Stäbchen in der Zahl wird dann über den Satz des Pythagoras ermittelt. 

Bei evolutionären Algorithmen spielt der Zufall eine zentrale Rolle. 
Um effizient Pseudozufallszahlen generieren zu können wird der \lstinline{std::mt19937}-Zufallszahlengenerator aus dem \lstinline{random}-Header der C++-Standardbibliothek verwendet. 
Für die Selektion nach Rang wird eine geometrische Verteilung aus der Standardbibliothek verwendet, da diese bessere Individuen wie gewünscht bevorzugt.

Der Algorithmus ist von einigen Parametern abhängig, die im \lstinline{TSPSolver}-Objekt eingestellt werden können. 
Standardmäßig wird eine Mutationsrate von $1\%$ und eine Populationsgröße von 100 Individuen verwendet. 
Außerdem werden für jede Generation 10 Individuen der Vorgängergeneration übernommen und 10 neue Individuen generiert. Auch diese Parameter können angepasst werden. 


\section{Beispiele}
Genügend Beispiele einbinden! Die Beispiele von der BwInf-Webseite sollten hier diskutiert werden, aber auch eigene Beispiele sind sehr gut – besonders wenn sie Spezialfälle abdecken. Aber bitte nicht 30 Seiten Programmausgabe hier einfügen!

\section{Quellcode}
Unwichtige Teile des Programms sollen hier nicht abgedruckt werden. Dieser Teil sollte nicht mehr als 2–3 Seiten umfassen, maximal 10.



\end{document}
